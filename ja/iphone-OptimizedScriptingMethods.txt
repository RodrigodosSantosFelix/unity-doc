!モバイル最適化のための実用ガイド - スクリプティング および ゲームプレイ手法 / Practical Guide to Optimization for Mobiles - Scripting and Gameplay Methods

このセクションはモバイル開発者がコードを書いてゲームが速く実行できるように構成する方法を解説します。ここで中心となる考え方はゲームデザインと最適化は完全に別々のプロセスではないということです。ゲームを設計するときの決定によりゲームを面白く速くすることが出来ます。

!! 歴史的な事例

(:div style="float:right; padding:5px":)
Attach:spaceInvaders.jpg
(:divend:)

過去の古いゲームで、プレイヤーが画面で一回づつしか発射できなかったころを思い出すと、リロードする速度はタイマーでなく、弾が外れたかどうかにより制御されていました。このテクニックは $$object pooling$$ と呼ばれて、メモリ管理をシンプルにして、プログラムの実行をスムーズにします。

スペースインベーダのクリエイターは RAM 容量が小さかったのみならず、プログラムが利用可能である以上のメモリを絶対に使用しないことを保証する必要がありました。もしプレイヤーに 1 秒ごとに発射すること、パワーアップによりリロード時間を 0.5 秒に縮めることを提供していたら、許してしまっていたら、プレイヤーが出来るかぎり発射を速く行い、発射物の持続時間が最も長い場合を想定して、たくさんの発射物を割り当てるだけの十分なメモリ空間を保証しないといけなくなります。これは彼らにとって問題となったであろうから、その代わりに発射物はひとつとして、そこで止めました。発射物が消滅するとすぐに、シンプルに無効化されて、再配置されたうえでもう一回発射されたときに有効化されます。それでも同じメモリ空間に居続けて、全く動かず繰り返し削除されたり再作成さるような必要がありません。


!!! 最適化、それともゲームプレイの宝石？

これはあまり現実味を感じないかもしれないが、 __面白い__ ものです。エイリアンのインベーダーが地面に迫ってくるような高潮する場面では、フィルムまたは文学のように、テンションが緩和されます。インベーダの近い近接さは名人のプレイヤーにほとんど瞬間的に近いリロード時間を与え、発射キーを完璧なタイミングで押すことで奇跡的に地球を守ります。良いゲームデザイン、インタラクティブな物語部と背景にあるそれを動かす技術との間にあるは奇妙な位置にあります。このようにクールで、楽しくて、効果的なものの計画を練るのは難しいことで、コードのロジスティクスおよびユーザのインタラクションは二つの激しく異なり、深くて気難しいであって、両方をあわせて何か新鮮で面白いものとして合成するのは多くの知恵と実験が必要です。

ゲームの全ての側面をインタラクションおよびモバイルのハードウェアに優しいものと同時にすることは無理でしょう。それよりも、こういった "宝石" のように両者が偶然に実験している間に調和してくるほうがありがちです。しかしコードが自分がデプロイしようと考えているハードウェアでどう実行されているのか完全に理解することが役立ちます。もしオブジェクトプーリングがなぜ良いのかの詳細な技術的説明およびメモリの割り当てについて学ぶには [[Main.iphone-PracticalScriptingOptimizations | スクリプティング 最適化]] を参照して下さい。


!! X はモバイルで速く動作するか?

例えばゲームの作成を始めたところで、多くのアクションと派手なことを同時にしてプレイヤーの気を引きたいとします。どうやってその計画を練ればよいのか？どこに制約があるのか、ゲーム用語で言えばどれぐらいのコイン、いくつのゾンビ、敵の車は何台で、などどうやって知れば良いのか。それはすべて自身のゲームをどうコードするかに依存します。

一般的に、もしゲームのコードを簡単な方法で、すなわち最も普遍的で融通の利く方法で作成すると、パフォーマンスの問題により早く遭遇します。ゲームを実行するには、特定のパターンやテクニックを活用すれば、道は拓けてきて画面上により多くを詰め込むことが出来ます。

!!! 簡単で融通が利くけど、遅い

* Rigidbody を 2次元に限定した 2Dゲーム
* Rigidbody を発射物にアタッチ
* Instantiate および Destroy を頻繁に使用
* 個別の 3D オブジェクト を アイテム や キャラクター が大量
* 毎フレーム計算を実行
* GUI または HUD のために OnGUI を使用

!!! 複雑 かつ 限定されているが、速い

* 2D ゲームのために自身の物理計算コードを記述
* 発射物の衝突判定を自身でハンドリング
* Instantiate および Destroy の代わりにオブジェクトプーリングを使用
* パーティクルにアニメーションつきスプライトを使用してシンプルなオブジェクトを表現
* 高価な計算は数フレームおきにして、結果をキャッシュ
* カスタムのGUIソリューション

!! サンプル

(:div style="float:right; padding:5px":)
Attach:coinsLighting.jpg
(:divend:)

!!! 回転していて、動的ライティングがなされて、集められるコインが画面上に同時に百個ある

* 悪い例: 各コインは Rigidbody のアタッチされた別々のオブジェクトであり、スクリプトが回転させて拾うことを許容する

* 良い例: コインはアニメーションつきテクスチャのあるパーティクルシステムで、ひとつのスクリプトが全てのコインの衝突テストを行い、ライトからの距離にもとづいてカラーをセットする。
** このサンプルは [[Main.iphone-PracticalScriptingOptimizations#Animated_Sprite_Particle_System | スクリプティング最適化]] ページで実装されています。

!!! カスタム 作成したソフトボディ シミュレーション

* 悪い例: ゲーム世界に 枕があちこちにあり、投げて山積み出来る

* 良い例: 自身のキャラクターが枕であり、それはひとつしかなく、およびどこなのか何らか予想できる（球や軸が整列したキューブとのみ衝突）。完全な機能まではないソフトボディ シミュレーションをコーディングして、それでいて見映えが良く素早く実行させる

!!! 30 人の敵キャラクターがプレイヤーへ向けて同時に発射する

* 悪い例: 各々の敵は、自身のスキンメッシュがあり、武器を別のオブジェクトとして、発射する度に Rigidbody ベースの発射物をインスタンス化。毎フレームごとに実行される AI スクリプトにて各々の敵は同胞の状態を考慮する

* 良い例: ほとんどの敵は遠く離れていて、ひとつのスプライトで表現、または、敵は 2D として何個かのスプライトのみからなる。敵の弾丸は同じパーティクルシステムにより描画され、原始的な物理計算により再現する。各々の敵は AI 状態をそのセクターにいる敵の状態にもとづいて 毎秒あたり2回だけ更新する。

!! スクリプト最適化の疑問について

次の [[Main.iphone-PracticalScriptingOptimizations | スクリプトの最適化]] を参照して下さい。


(:tocportion:)

