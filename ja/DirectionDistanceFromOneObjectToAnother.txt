! ひとつのオブジェクトから別のオブジェクトへの向きと距離

もし空間上の1点を別の点から引くと結果はひとつのオブジェクトからもうひとつを "指す" ベクトルとなります。



[@// プレイヤーの位置からターゲットの位置を指すベクトルを取得します。
var heading = target.position - player.position;@]
	
ターゲットオブジェクトの方向を指すとともに、このベクトルの大きさは二つの位置の間の距離に等しくなります。一般的にはターゲットを向いた正規化されたベクトルが必要となります（発射物を向ける場合も同様）。オブジェクトの間の距離は向かっているベクトルと等しく、このベクトルを正規化するためには大きさで割ります:-

[@var distance = heading.magnitude;
var direction = heading / distance;  // これで方向が正規化されました。@]

このアプローチは大きさ（magnitude）と正規化されたプロパティの両方を別に使用する場合と比べ、両方ともにCPUをかなり消費するため（両方とも平方根計算を含むため）より望ましいです。


もし距離だけの比較が必要な場合（例えば近接度合いのチェック）であれば、大きさの計算そのものを回避できます。sqrMagnitude プロパティにより magnitude の値の累乗が得られ、 magnitudeのように計算されますが時間を消費する平方根計算をさけられます。大きさを既知の距離と比較するのではなく、大きさの2乗と距離の2乗を比較できます:-

[@if (heading.sqrMagnitude < maxRange * maxRange) {
	// ターゲットは範囲内
}@]

これは新の大きさを比較で使用するよりも遥かに効率的です。

しばしば真上から見たターゲットへの向きが必要な場合があります。例えば、地面に立っている人が空中にういているターゲットに向かう必要がある場合を想像します。もし、プレイヤーの位置からターゲットの位置を引き算すると、結果のベクトルはターゲットに向かって上方向になります。これはプレイヤーの transform の向きを決めるには適切ではなく、プレイヤー自身も上向きに傾いてしまいます。実際に必要であるのはプレイヤーの位置からターゲットの真下の位置へのベクトルです。これは引き算した結果の Y座標をゼロにすることで容易に得られます。

[@var heading = target.position - player.position;
heading.y = 0;	// これが真上からみた向きです。@]

