! リジッドボディ

$$Rigidbody$$ により、 $$GameObject$$ が物理特性の制御下で動作するようになります。 リジッドボディは、力やトルクを受け、現実的な方向にオブジェクトを動かすことができます。  GameObject は、重力の影響を影響を受けるリジッドボディを含めるか、スクリプティングを通じて加えた力の下で動作するか、NVIDIA PhysX 物理特性エンジンを通じて、その他のオブジェクトと相互作用する必要があります。

Attach:Inspector-Rigidbody.png\\
「リジッドボディにより、GameObject は物理的影響の下で動作できます」


!! プロパティ

||PROPS
||``Mass`` ||オブジェクトの質量 (単位	: kg)。 質量をその他のリジッドボディの 100 倍 にしておくことをお勧めします。 ||
||``Drag`` ||力により動く際に、オブジェクトに影響する空気抵抗の量。 0 の場合、空気抵抗が 0 で、無限の場合、オブジェクトは直ちに動きを止めます。 ||
||``Angular Drag`` ||トルクにより回転する際に、オブジェクトに影響する空気抵抗の量。 0 の場合、空気抵抗が 0 で、無限の場合、オブジェクトは直ちに回転を止めます。 ||
||``Use Gravity`` ||有効にすると、オブジェクトは重力の影響を受けます。|| ||
||``Is Kinematic`` ||有効にすると、オブジェクトは物理特性エンジンによって駆動されませんが、その $$Transform$$ によってのみ操作できます。 これは、プラットフォームを移したい場合や、$$HingeJoint$$ を追加したリジッドボディをアニメート化したい場合に便利です。 ||
||``Interpolate`` ||リジッドボディの移動でギクシャクした動きを求めている場合にのみこのオプションのいずれかを試します。 ||
||>>>``None`` ||補間は適用されません。 ||
||>>>``Interpolate`` ||前のフレームのトランスフォームに基づいて、トランスフォームを円滑にします。 ||
||>>>``Extrapolate`` ||次のフレームの推定トランスフォームに基づいて、トランスフォームを円滑にします。 || 
||``Freeze Rotation`` ||有効にすると、GameObject はスクリプトを通じて追加される衝突または力に基づいて回転しません。「transform.Rotate()」を使用した場合のみ回転します。 ||
||``Collision Detection`` ||高速で移動するオブジェクトが、衝突を検出せずに、他のオブジェクトを通過させないようにする場合に使用します。 ||
||>>>``Discrete`` ||シーン内のその他すべてのコライダに対して、個別の衝突検出を使用します。 その他のコライダは、衝突のテスト時に個別衝突検出を使用します。 通常の衝突に使用されます (これはデフォルト値です)。 ||
||>>>``Continuous`` ||動的衝突 (リジッドボディとの) に対する個別衝突検出と、スタティックな MeshColliders との連続衝突検出 (リジッドボディなし) を使用します。 Rigidbodies set to Continuous Dynamic に設定されたリジッドボディは、このリジッドボディへの衝突をテストする際に、連続衝突検出を使用します。 その他のリジッドボディは、個別衝突検出を使用します。 連続衝突検出が衝突を必要とするオブジェクトに使用されます。 (高速のオブジェクトの衝突に関して問題がない場合は、これは、物理特性パフォーマンスに大きく影響するため、個別に設定しておきます) ||
||>>>``Continuous Dynamic`` ||連続および連続動的衝突に設定されたオブジェクトに対して、連続衝突検出を使用します。 スタティックな MeshColliders との連続衝突検出も使用します (リジッドボディなし)。 その他すべてのコライダに対しては、個別衝突検出を使用します。 高速移動するオブジェクトに使用されます。||
||``Constraints`` ||リジッドボディの動きに関する制限:-||
||>>>``Freeze Position``||是界の X、Y、Z 軸で移動するリジッドボディを選択的に停止します。||
||>>>``Freeze Rotation``||是界の X、Y、Z 軸で回転するリジッドボディを選択的に停止します。||

!! 詳細

$$Rigidbody$$ により、GameObject が物理特性エンジンの制御下で動作するようになります。  これにより、現実的な衝突、多様な種類のジョイント、その他のクールな動作へのゲートウェイが開きます。  リジッドボディに力を加えることで、GameObject を操作することによって、 $$Component$$ を直接調整した場合とは違うルック & フィールを作成します。  一般に、リジッドボディと同じ GameObject のトランスフォームのどちらか一方だけを操作しないでください。

トランスフォームの操作とリジッドボディ間の最大の差は、力を使用するかしないかです。  リジッドボディは、力やトルクを受けることができますが、トランスフォームはできません。  トランスフォームは移動や回転はできますが、物理特性の使用とは異なります。 自分で試した場合は、その顕著な差に気づくでしょう。  リジッドボディに力/トルクを加えると、実際にオブジェクトの位置やトランスフォーム コンポーネントの回転を変更します。  このため、どちら一方だけを使用する必要があります。  物理特性使用中にトランスフォームを変更すると、衝突やその他の計算に問題が生じる場合があります。

リジッドボディは、物理特性エンジンに影響を受ける前に、GameObject に明示的に追加する必要があります。  メニューバーで「Components->Physics->Rigidbody」から選択したオブジェクトにリジッドボディを追加できます。 オブジェクトで物理特性の準備ができました。重力下に置かれ、スクリプティングを介して、力を受けることができますが、 $$Collider$$ またはジョイントを追加して、正確に希望通りに動作させる必要があります。


!!! 親子関係

オブジェクトが物理特性の制御下にある場合、トランスフォームの親が移動する方法から半分独立して移動します。 親を移動すると、リジッドボディの子をそれに沿って引っ張ります。 しかし、リジッドボディは重力および衝突イベントへの対応により、落下していきます。


!!! スクリプティング

リジッドボディをコントロールするため、最初にスクリプトを使用して、力またはトルクを追加します。 「[[ScriptRef:Rigidbody.AddForce.html|AddForce()]]」 と「[[ScriptRef:Rigidbody.AddTorque.html|AddTorque()]] 」をオブジェクトのリジッドボディで呼び出すことでこれを行います。  物理特性を使用する際は、オブジェクトのトランスフォームを直接買えないようにしてください。


!!! アニメーション

一部の状況で、主にラグドール効果を作成する場合に、アニメーションと物理特性間でオブジェクトのコントロールを切り替える必要があります。 このため、リジッドボディには、「[[ScriptRef:Rigidbody-isKinematic.html|isKinematic]] 」と付けることができます。 リジッドボディに「isKinematic」と付いている場合、衝突や力、physX のその他の部分の影響を受けません。 This means that you will have to control the object by manipulating the [[class-Transform|Transform]] コンポーネントを直接操作することで、オブジェクトをコントロールする必要があるということです。  キネマティック リジッドボディはその他のオブジェクトに影響しますが、これら自体は物理特性の影響を受けません。 例えば、キネマティック オブジェクトに追加されるジョイントは、そこに追加されたその他のリジッドボディを制約し、キネマティック リジッドボディは衝突を通じて、その他のリジッドボディに影響します。


!!! コライダ

コライダは、衝突を発生させるために、リジッドボディと共に追加する必要のある別の種類のコンポーネントです。  2 つのリジッドボディが互いに衝突する場合、物理特性エンジンは、両方のオブジェクトもコライダを追加するまで、衝突を計算しません。  コライダのないリジッドボディは、物理特性シミュレーション中に互いを簡単に通過します。

Attach:RigidbodyandCollider.png\\
「コライダはリジッドボディの物理特性の境界を定義します」

「Component->Physics」メニューでコライダを追加します。  詳細については、個々のコライダのコンポーネント リファレンス ページを参照してください。
*[[class-BoxCollider|Box Collider]] - キューブのプリミティブの形状
*[[class-SphereCollider|Sphere Collider]] - 球体のプリミティブの形状
*[[class-CapsuleCollider|Capsule Collider]] - カプセルのプリミティブの形状
*[[class-MeshCollider|Mesh Collider]] - オブジェクトのメッシュからコライダを作成し、別のメッシュ コライダとは衝突できません
*[[class-WheelCollider|Wheel Collider]] - 車両またはその他の移動する乗り物の作成用


!!! 複合コライダ

(:include comp-ColliderCompound:)

!!! 連続衝突検出

連続衝突検出は、高速移動するコライダが互いに通過しないようにする機能です。 これは、通常の(「Discrete」) 衝突検出使用時、オブジェクトが 1 つのフレームでコライダの片側にあり、次のフレームでコライダを通過している場合に発生することがあります。 これを解決するには、高速移動するオブジェクトのリジッドボディで連続衝突検出を有効にできます。 衝突検出モードを「Continuous」に切り替え、リジッドボディがスタティックな (つまり、非リジッドボディ) MeshColliders を通過させないようにします。 衝突検出モードを「Continuous Dynamic」に切り替え、リジッドボディが、衝突検出モードを「Continuous」または「Continuous Dynamic」に設定したその他のサポートされているリジッドボディを通過させないようにします。 
連続衝突検出は、Box-、Sphere- および CapsuleCollider でサポートされています。

!! 正しいサイズの使用

GameObject のメッシュのサイズは、リジッドボディの質量よりもはるかに重要です。  リジッドボディが期待通りに動作しなていない場合、ゆっくり移動するか、浮くか、正しく衝突しません。  Unity のデフォルトの単位スケールは、1 単位 = 1 メートルなので、インポートされたメッシュのスケールは維持され、物理特性計算に適用されます。  例えば、倒壊しかけている高層ビルは、積み木で作った塔とはかなり違う形で崩れるため、正確にスケールするには、サイズの異なるオブジェクトをモデル化する必要があります。

人間をモデリングしている場合、Unity では、その人間の身長は約 2メートルになります。 オブジェクトが正しいサイズかどうかを確認するには、デフォルトのキューブと比較します。 ^^GameObject->Create Other->Cube^^ を使用して、キューブを新規作成します。 キューブの高さは、ちょうど 1 メートルになるため、作成している人間は 2 倍の慎重になります。

メッシュ自体を調整できない場合、$$Project View$$ で選択し、メニューバーから ^^Assets->Import Settings...^^ を選択することで、特定のメッシュ　アセットの均一なスケールを変更できます。  ここでは、スケールを変更し、メッシュを再インポートできます。

ゲームで、GameObject を異なるスケールでインスタンス化する必要がある場合、トランスフォームのスケール軸の値を調整しても大丈夫です。  欠点は、物理特性シミュレーションは、オブジェクトのインスタンス化時に更に多くの作業を剃る必要があり、ゲーム内でパフォーマンスの低下を引き起こす可能性があります。  これは大きな損失ではありませんが、他の 2 つのオプションでスケールを仕上げることほど効率的ではありません。  不均一なスケールだと、パレンディング使用時に望まぬ動作を生じる場合があります。  このため、モデリング アプリケーションで正しいスケールでオブジェクトを作成するのが常に最適です。


!! ヒント
* 2 つのリジッドボディの相対的な「Mass」は、リジッドボディが互いに衝突する際に、どのように反応するかを決定します。
* 1 つのリジッドボディの「Mass」を他方より大きくしても、自由落下での落下速度は上がりません。 これを行うには、「Drag」を使用します。
* 「Drag」値が低いと、オブジェクトが重く見えるようになります。 この値が高いと、軽く見えます。 「Drag」の通常の値は、.001 (金属の塊) と 10 (羽) の間です。
* オブジェクトのトランスフォーム コンポーネントを直接操作しているが、物理特性が必要な場合、リジッドボディを追加し、キネマティックにします。
* トランスフォーム コンポーネントを通じて、GameObject を移動させているが、衝突/トリガー メッセージを受信したい場合は、リジッドボディを移動しているオブジェクトに追加する必要があります。
