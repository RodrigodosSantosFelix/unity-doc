! プロファイラー (Unity Pro のみ)

Unityプロファイラーはゲームの最適化に役立ちます。ゲームの様々な要素で要した時間を報告してくれます。例えばゲームロジックのレンダリング、アニメーションに要した時間の割合が分かります。

プロファイリングを有効にしてエディタで実行することが出来て、パフォーマンスを記録することが出来ます。次にProfiler ウィンドウがデータをタイムラインで表示するため、スパイクした (他より時間を要した) フレームや要素が分かります。タイムライン上の任意の位置をクリックすることでProfilerウィンドウの下部に選択したフレームの詳細情報が表示されます。

プロファイリングがコードを "測定する" ことに留意して下さい。測定はゲームのパフォーマンスにわずかな影響があります。一般的にはこのオーバーヘッドはゲームのフレームレートに影響するほどの大きさするときではありません。プロファイリングを使用するとき、特定のエリアで要した時間の割合 (またはパーセンテージ) のみを考慮することが一般的です。さらにパフォーマンスを改善するためには時間を最も要する部分のみにフォーカスして下さい。コード変更の前後のプロファイリングの結果を比較して改善結果を測定します。場合によっては行った変更がフレームレートにマイナス影響を与える場合があり、コード最適化による想定外の結果があることを加味すべきです。

Attach:ProfilerWindow2.png\\
''Profiler ウィンドウ''

!! Unity プレイヤーへのアタッチ
ゲームが他のデバイスまたは他のコンピュータでプレイヤーにより実行されているのをプロファイリングするためには他のプレイヤーにエディタを接続することが可能です。ドロップダウンの __Active Profiler__ によりローカルネットワークで実行されている全てのプレイヤーご表示されます。これらのプレイヤーはプレイヤーの種類とプレイヤーが実行されているホスト名"iPhonePlayer (トムの iPhone)" で識別できます。プレイヤーに接続するためには
 iPhone)"。_Build Settings_ダイアログの__Development Build__ チェックボックスを有効にして起動する必要があります。その先はさらにチェックボックスを選択してエディタおよびプレイヤーを起動時に自動接続させることが出来ます。

!! プロファイラーのコントロール

Attach:ProfilerControls.png

プロファイラーのコントロールはウィンドウ上部のツールバーにあります。プロファイリングを有効/無効にするのにこれらを使用し、プロファイリングされたフレームを操作する、等々に使用して下さい。トランスポートのコントロールはツールバーの一番右端にあります。ゲームが実行されていてプロファイラーがデータを収集している間、これらのトランスポートのコントロールをクリックすることでゲームがポーズされます。コントロールはまず最初の記録されたフレームに移動して、1フレーム戻り、1フレーム進んで各々の最終フレームに移動します。プロファイラーは全ての記録されたフレームを保持せず、 ''first'' フレームの捉え方はメモリに残っている最も古いフレームと考えるべきです。 "current" トランスポート ボタンによりリアルタイムで収集されたデータを表示します。Active Profiler ポップアップメニューによりプロファイリングがエディタで行うべきか別のプレイヤー (例えば接続されたiOSデバイスで実行されているゲーム) で行うべきかを選択できます。

!!! ディープ プロファイリング

``Deep Profile`` を有効にすると ''全ての'' スクリプトコードがプロファイリングされます  - すなわち全ての関数コールが記録されます。これはゲーム コードの正確にどこで時間を要したかを知りたいときに便利です。

ディープ プロファイリングは __非常に大きなオーバーヘッド__ を要するとともにメモリも大量に使用するため、プロファイリングしている間にゲームが著しく遅くなります。もし複雑なスクリプトコードを使用している場合、ディープ プロファイリングは完全に無理である場合があります。ディープ プロファイリングはシンプルなスクリプトつきの小規模なゲームでは十分に速く動作します。もしゲーム全体で使用するとげがほとんど実行出来ないほどフレームレートが落ちる場合、このアプローチは避けるべきで代わりに以下に説明するアプローチを使用すべきです。ディープ プロファイリングはゲームを設計しながら鍵となる機能をどう実装するか決めるときに役立ちます。大規模なゲームではディープ プロファイリングによりUnityがメモリ不足に陥るためこの場合は不可能かもしれません。

手動でスクリプトのブロックをプロファイリングすることはディーププロファイリングよりもオーバーヘッドがかかります。 [[ScriptRef:Profiler.BeginSample.html | Profiler.BeginSample]] および [[ScriptRef:Profiler.EndSample.html | Profiler.EndSample]] スクリプティング関数を使用してコードのセクション周りのプロファイリングを有効化/無効化します。

!! SyncTimeの表示

固定フレームレートまたは垂直ブランクと同期するとき、Unityは待ち時間を "Wait For Target FPS" に記録します。デフォルトではこの時間はプロファイラーに表示されていません。待ち時間に要したじかんを表示するには "View SyncTime" をオンにします。これはフレームを失い始めるまでの空きスペースに該当します。

!! プロファイラー タイムライン

Attach:ProfilerTimeline.png

プロファイラーウィンドウの上側にある期間のパフォーマンスを表示します。ゲームを実行したとき、データは毎フレーム記録されて、直近の100フレームの履歴が表示されます。特定フレームをクリックすることでウィンドウの下部に詳細が表示されます。どのタイムラインのエリアを現在選択しているかによって異なる詳細が表示されます。

タイムラインの垂直方向のスケールは自動的に管理されていてウィンドウの垂直方向のスペースを埋めようたもします。例えばCPU使用率でより詳細を確認したいとき、メモリやレンダリングのエリアを閉じます。さらにタイムラインと統計情報の間の枠線を選択してドラッグすることでタイムラインのチャートで使用される画面領域を増やすことご出来ます。

タイムラインはいくつかのエリアからこうせいされます: CPU使用率、レンダリング、およびメモリです。これらのエリアを閉じるにはパネルの close ボタンをクリックし、もう一回追加するにはProfile Controls バーの、 ''Add Area'' ドロップダウンを使用します。

!! CPU 使用率エリア

Attach:ProfilerCPU.png

CPU 使用率エリアはゲームで使用された時間を表示します。選択したとき、下側のパネルは選択されたフレームの階層データを表示します。

* __Hierarchy mode:__ 階層により時間データを表示。 hierarchical time data.
* __Group Hierarchy mode:__ データを論理グループ (Rendering, Physics, Scripts その他) に分けます。グループのあらゆる子が別のグループに存在出来るため (例えば スクリプトがレンダリングを呼ぶ、等)、グループの時間は100%を超えることがしばしばあります (バグではありません) 。

CPUチャートの縦の並び順はチャートラベルを上下にドラッグするだけで並び替えできます。

低いペインでアイテムが選択されたとき、CPUチャートに占める割合がハイライトされます (それ以外は暗くなります)。再度クリックすることで選択範囲から除きます。

Attach:ProfilerCPUSelected.png\\
''Shader.SetPass は選択されていてそれが全体に占める割合はチャートでハイライトされます。''

階層タイムデータの中で self time は特定の関数についてサブ関数を呼ぶ時間を含まない残りの時間を示します。上記のスクリーンショットでは例えば時間の 51.2% がCamera.Render関数に時間を要しています。この関数は多くの作業を行って様々な描画およびカリングの関数をコールします。これらの関数を取り除くとCamera.Render関数に要した時間は0.8%のみです。

!! レンダリング エリア

Attach:RenderProfiler35.png

レンダリング エリアはレンダリング統計を表示します。ドローコールの数、三角形数、および頂点数がタイムラインにグラフ表示されます。低いペインはより多くのレンダリング統計を表示し、そしてこれらはGameView [[RenderingStatistics | Rendering Statistics]] ウィンドウとより一致します。


!! メモリ エリア

Attach:ProfilerMemory.png

メモリ エリア はいくつかのメモリ使用に関するデータを表示します:
* ``Total Allocated`` はアプリケーションにより使用されたRAM 容量の合計です。Unityエディタではこのメモリはエディタで全て使用され、ゲームビルドでは遥かに少なく使用されます。
* ``Texture Memory`` 現在のフレームで使用されるビデオメモリの量。
* ``Object Count`` 作成されたオブジェクトの総数です。もしこの数値が時間経過とともに増える場合、ゲームが破棄されないオブジェクトを作成しているということです。
[[#Audio]]
!! オーディオ エリア

Attach:AudioProfiler35.png

オーディオ エリアは音声に関する統計を表示します:
* ``Playing Sources`` はシーンにある再生されたオーディオ ソースの特定フレームにおける合計です。もし音声がオーバーロードされている場合にはモニタリングして下さい。
* ``Paused Sources`` はシーンにあるポーズされたオーディオ ソースの特定フレームにおける合計です。
* ``Audio Voice`` はオーディオ（FMODチャネル）ボイスの実際の数です。PlayOneShot は  Playing Sources で表示されないボイスを使用します。
* ``Audio Memory`` はオーディオ エンジンにより使用される RAM 容量の合計です。

CPU 使用率は下部でみることが出来ます。オーディオ単独でCPUを使用しすぎている場合はモニタリングして下さい。

__注意:__ Ogg Vorbis 形式のオーディオ アセットがCompressed In Memory を使用してインポートされると、プロファイラーにより報告されるメモリ使用が予想外に小さくなります。これは FMOD オーディオを使用するプラットフォームで発生します - FMOD は  Compressed In Memory を使用した Ogg Vorbis をサポートしないため、import setting は （遥かにメモリオーバーヘッドの少ない）Compressed In Memory に無条件で書き換えられます。。


!! 物理計算 エリア

Attach:PhysicsProfiler.png

物理計算 エリアによりシーンの物理計算に関する次の統計を表示します:-
* ``Active Rigidbodies`` は現在スリープしていない Rigidbody の数です（すなわち移動しているか、ちょうどスリープに入る前か）。
* ``Sleeping Rigidbodies`` は完全にスリープに入っている Rigidbody の数、すなわち物理エンジンによりアクティブに更新する必要がないものの数です（詳細については [[Rigidbody Sleeping]] を参照して下さい）。
* ``Number of Contacts`` はシーンにおける全てのコライダーの接触している数の合計です。
* ``Static Colliders`` は非 Rigidbody オブジェクトにアタッチされたコライダの数です（すなわち物理挙動を示すことがないオブジェクト）。
* ``Dynamic Colliders`` はRigidbody オブジェクトにアタッチされたコライダの数です（すなわち物理挙動を示すオブジェクト）。

!!GPU エリア

Attach:GPUProfiler.png

GPU プロファイラは CPU プロファイラと似て、レンダリング タイム に占める割合を最下部のパネルに階層として表示されます。階層からアイテムを選択することで右側に内訳が表示されます。

Mac 上では、GPU プロファイリングは OSX 10.7 Lion 以降でのみ利用可能です。

!! さらに詳細について

* [[OptimizingGraphicsPerformance | グラフィックス パフォーマンス最適化]] ページ。

>>ios<<
!! iOS
リモートプロファイリング は 次の手順により iOS デバイスで有効化できます:
# iOS デバイスを WiFi ネットワークに接続します（デバイスから Unity エディタにプロファイリングデータを送信するためにプロファイラはローカル／アドホック WiFi ネットワークを使用します）
# UnityのBuild Settings ダイアログで "Autoconnect Profiler" をチェックします。
# ケーブル経由で Mac にデバイスを接続し、Unity エディタで "Build & Run" をクリックします。
# デバイスでアプリが起動した後、Unity エディタで Profiler ウィンドウを開きます。(Window->Profiler)

ファイアウォールを使用している場合、 送信のルールでポート番号  54998 to 55511が 開放されていることを確認します - これらのポートは Unity によりリモートプロファイリングで使用されます。

__注意:__ Unity エディタはデバイスに自動接続しない場合があります。そのような場合は、プロファイラの接続は Profiler ウィンドウの ``Active Profiler`` ドロップダウンメニューで適切なデバイスを選択して開始できます。
>><<

>>android<<
!! Android
リモートプロファイリング は 異なるパスにより Android デバイスで有効化できます: WiFi または [[ http://developer.android.com/guide/developing/tools/adb.html | ADB ]] 。

WiFi プロファイリングでは、次のステップに従います:
# Androidデバイスで モバイルデータ通信 を無効化します。
# Android デバイスを WiFi ネットワークに接続します。
# UnityのBuild Settings ダイアログで "Autoconnect Profiler" をチェックします。 
# ケーブル経由で Mac/PC にデバイスを接続し、Unity エディタで "Build & Run" をクリックします。
# デバイスでアプリが起動した後、Unity エディタで Profiler ウィンドウを開きます。(Window->Profiler)
# もしUnity エディタがデバイスに自動接続しない場合、Profiler ウィンドウの ``Active Profiler`` ドロップダウンメニューで適切なデバイスを選択します。
__注意:__ Android デバイス および （Unity エディタを実行している）ホストコンピュータ は両方とも同じ [[ http://en.wikipedia.org/wiki/Subnetwork | サブネット ]] にないとデバイス検知が正しく動作しません。

ADB プロファイリングを行うには、次の手順に従います:
* ケーブル経由で Mac/PC にデバイスを接続し、ADB がデバイスを認識することを確認します（すなわち ''adb devices'' のリストに表示されます）。
* ターミナル/コマンドウィンドウを開き、次を入力
->@@adb forward tcp:54999 localabstract:Unity-<バンドル識別子をここに記述>@@
* Unity の Build Settings ダイアログで "Development Build" をチェックし、"Build & Run" をクリックします。
* デバイスでアプリが起動した後、Unity エディタで Profiler ウィンドウを開きます。(Window->Profiler)
* Profiler ウィンドウの ``Active Profiler`` ドロップダウンメニューで ''AndroidProfiler(ADB@127.0.0.1:54999)'' を選択します。
__注意:__ ドロップダウンメニューのエントリは選択されたターゲットが Android の場合のみ表示されます。

ファイアウォールを使用している場合、 送信のルールでポート番号  54998 to 55511が 開放されていることを確認します - これらのポートは Unity によりリモートプロファイリングで使用されます。

>><<
