! ウェブプレイヤーの信頼の連鎖を使用する / Using the Chain of Trust system in the Web Player

このセクションでは強力にネーミングされたアセンブリを作成して使用して、Javascript と連携させ自身のカスタム バックエンドと連動する方法を、学びます。

信頼の連鎖は外部のインターネット アプリケーションを許可して、Unity ウェブプレイヤーから生成されたリクエストを信頼します。これは完全な機能を持った API を Unity ウェブプレイヤーでゲームを作成する Unity 開発者に提供したい場合は便利です。信頼の連鎖を使用するためにリクエストを受付するバックエンドのインターネット アプリケーションが必要であり、最も一般的な例は REST API を使用したウェブ アプリケーションです。インターネット アプリケーションをコールするためのマネージド C# アセンブリのコードを保有している必要があります。

!! キーペアの生成
信頼の連鎖を確立する最初のステップはアセンブリを署名するのに必要な暗号化されたキーペアを作成することです。この作業は Windows, OS X または Linux上で SN ツールを使用して行います。

# 新しいキーペアを作成するにはコマンドラインを開き、次の通りに入力します:

 [@ sn -k myNewKey.snk @]

# @@myNewKey.snk@@ を、自身が適切と考える名前で置き換えます。 ファイル名は信頼の連鎖の観点では何でもかまいません。
# .SNK ファイルを保持します。このファイルが漏洩する、または悪意のある開発者であればアセンブリを解析する可能性があります。

!! アセンブリの署名
次に生成したキーペアを使用して自身のマネージド C# アセンブリ（バックエンドの呼び出しに使用するもの）を署名します。  Windows, OS X および Linux に含まれる@@al@@ ツールを使用する必要があります。

アセンブリの署名は簡単なプロセスです。
# コマンドラインターミナルを開き、マネージド C# アセンブリへと移動し、次の通りに入力します:

 [@ al /out:mySignedAssembly.dll myUnsignedAssembly.dll /keyfile:myNewSky.snk @]

 *@@mySignedAssembly.dll@@ は希望する自身の最終的なアセンブリ名です。
 *@@myUnsignedAssembly.dll@@ は自身の通常の、署名していないマネージド C# アセンブリです。
 *@@myNewKey.snk@@ は自身の暗号化されたキーペア ファイルです。
# @@al@@ が一回実行完了すると、自身の署名されたアセンブリは準備完了となります。Unity プロジェクト上にドロップして信頼の連鎖に使用します。

!! 秘密事項のインジェクト
Unity ウェブプレイヤーには Unity ゲームがロードされた後にいつでも秘密事項をインジェクト出来ます。これは Javascript オブジェクトの@@UnityObject2@@ で公開されている Javascript の $$SendMessage$$ により実現出来ます。

特定のゲームオブジェクトに特有フォーマットのメッセージを渡す時、信頼の連鎖は秘密事項をインジェクトしたいことを検知してメッセージをインターセプトします。このシステムを使用するのにゲームオブジェクトをリネームする必要は全くありません。  @@u@@ と呼ばれる@@UnityObject2@@ インスタンスによる Javascript コールは:

[@ u.GetUnity().SendMessage("ChainOfTrust_SetValueASDF", ".", "name=mySecretDataName;value=mySecretValue;publickey=publicKeyTokenOfMyAssembly"); @]

* $$SendMessage$$ 関数は標準的な ``MonoBehaviour/SendMessage`` 関数と似通っている。3 つの名目 の引数をとる:
** ターゲット ゲームオブジェクトの名前
** 実行するメソッドの名前、および
** 文字列の引数
* 信頼の連鎖によりメソッドの名前は完全に無視されます。ターゲットゲームオブジェクトの名前は @@ChainOfTrust_SetValue@@ で始める必要があり、しかしながら @@ChainOfTrust_SetValue@@ の後に記述した文字列は安全に無視出来ます。
*文字列の引数のフォーマットは非常に重要です。信頼の連鎖はセミコロンにより三段階に分かれています。確認される内容は:
** @@name@@, 
** @@value@@ , および
** @@publickey@@
大文字小文字は重要です。これらのキーワードは小文字とすることが必須であり、その後続に 等号記号 (@@=@@) が必須です。
* 秘密事項には任意の @@name@@ を適用出来ます。先の例では @@mySecretDataName@@ を上記サンプル上で置き換えます。
*@@value@@ は共有鍵、または信頼の連鎖に格納する他の秘密事項です。具体的にこの値に何を格納するかは固有のアプリケーションに特有です。先の例では @@mySecretDataValue@@ を上記サンプル上で置き換えます。
* @@publickey@@ はマネージドC# アセンブリを署名したパブリックキーのトークンです。 @@sn@@ ツールを使用して、署名したアセンブリ上で見つけることが出来ます:

 [@ sn -T mySignedAssembly.dll @]

パブリックキー トークンを前後に空白スペースなしに複製し、先の例では@@myPublicKeyToken@@ を上記サンプル上で置き換えます。
*バーチャル ゲームオブジェクトの名前にランダムなデータを付加します。ウェブプレイヤーを使用する全ての人が最新の ウェブプレイヤー ランタイムを持っていることを保証する方法はないため、全てのウェブプレイヤーが $$SendMessage$$ コールをインターセプトするとはかぎりません。もし悪意のある開発者が Javascript をみて、バーチャル ゲームオブジェクトと使用している関数をみると同じ名前でそのメソッドを実装したUnity ゲームオブジェクトを作成することが出来ます。この特定のケースで悪意のある開発者のコードは最新でないバージョンのウェブプレイヤーで動作して、共有の秘密事項をインターセプトして望まれないコールをバックエンドに対して実行するかもしれません。ゲームオブジェクトの名前をランダムにすることで誰かに信頼の連鎖を古いランタイムでインターセプトすることが難しくなります。

!! 自身の秘密事項を受け取る
Unity ウェブプレイヤーに秘密事項をインジェクトした後は、暗号化署名された ("強い名前の") マネージド C# アセンブリをマッチングふるパブリックキー トークンによってのみ受け取ることが出来ます。
* マネージド C# アセンブリは$$Security.GetChainOfTrustValue$$ をコールして秘密事項を受け取る必要があります。$$GetChainOfTrustValue$$  では、payload の@@name=@@ 構文で、秘密事項の名前を渡す必要があります。
* $$GetChainOfTrustValue$$ は秘密事項の値をクリア テキストとして戻し、アセンブリの中でそれを使用することが出来ます。
* インジェクション payload において @@name=mySecret;value=superSecretData;publickey=A92181sn828O@@ とすると、マネージド C# アセンブリの中で秘密事項を受け取るコードは:

 [@ string myValue = Security.GetChainOfTrustValue("mySecret"); @]

* 秘密事項の値をセキュアにするために多くの苦労をしているため、秘密事項の値はマネージド C# アセンブリの外にある何らかの関数またはコードに渡すべきではありません。
* 署名されてないコードから$$Security.GetChainOfTrustValue$$ をコールするための試行、または署名されたアセンブリでシグニチャが秘密事項の指定されたパブリックキー とマッチングしないコードからの試行は、ログ上でエラーご記録されて、$$Security.GetChainOfTrustValue$$ は空白の文字列を戻します。
