! スクリプトの使用

この短い紹介文の中でプロジェクトでスクリプトを作成および使用する方法を説明します。スクリプティングAPI についての詳細については [[Path:../ScriptReference/index.html|Scripting Reference]] を参照下さい。スクリプティングを通じたゲームプレイの作成の詳細についてはこのマニュアルの [[Creating Gameplay]] を参照下さい。

Unityの Behaviour スクリプトは $$JavaScript$$, $$C#$$, または $$Boo$$ で作成することが出来ます。これらの3つの言語をひとつのプロジェクトで組み合わせて使用することが出来ますが、ひとつのスクリプトが別のスクリプトを参照する場合には特定の制限があります。



!! 新しいスクリプトの作成

メッシュやテクスチャといった他のアセットと違って、Unityの中でスクリプトファイルを作成することが出来ます。新しいスクリプトを作成するには、メニューから ^^Assets->Create->JavaScript^^ (または ^^Assets->Create->C Sharp Script^^ または ^^Assets->Create->Boo Script^^) を開きます。これにより ``NewBehaviourScript`` という名前のスクリプトが $$Project View$$ の選択フォルダに作成されます。もし Project View にフォルダが選択されていない場合、フォルダはルートレベルに作成されます。

Attach:Scripting-1.png

Project View の中でスクリプトをダブルクリックすることで編集することが出来ます。これによりUnity の Preferencesで指定したデフォルトのテキストエディタが起動されます。デフォルトのスクリプトエディタを設定するには ^^Unity->Preferences->External Script editor^^ のドロップダウンのアイテムを変更します。

次に新規作成された、空のBehaviourスクリプトの中身です:

[@function Update () {
} @]


新規で、空のスクリプトはそれ自体では何もしないので、機能を追加してみます。次のようにスクリプトを変更してみて下さい:

[@function Update () {
    print("Hello World");
} @]

実行されたとき、このコードはコンソールに "Hello World" を出力します。しかし、コードを実行をトリガーするものがまだ何もありません。実行される前にスクリプトを $$Scene$$ 上のアクティブな $$GameObject$$ にアタッチする必要があります。


!! オブジェクトをスクリプトにアタッチする

前述のスクリプトを保存して、 ^^GameObject->Create Other->Cube^^ と選択することでシーンに新規のオブジェクトを作成します。これにより "Cube" という名前の新規のゲームオブジェクトを現在のシーンに作成します。

Attach:Scripting-2.png

次にプロジェクトビューからスクリプトをキューブ上にドラッグ＆ドロップします（シーン または $$Hierarchy View$$ （階層ビュー）どちらでも問題ありません）。さらにキューブを選択して ^^Component->Scripts->New Behaviour Script^^ を選択することもできます。いずれかの方法によりキューブにスクリプトがアタッチされます。全ての作成されたスクリプトは ^^Component->Scripts^^ メニューに表示されます。

Attach:Scripting-3.png

キューブを選択して、 $$Inspector$$ をみると、スクリプトが表示されています。すなわちアタッチに成功しています。

Attach:Scripting-4.png
$$Play$$ （再生）ボタンをクリックして作成したものをテストします。Play/Pause/Step ボタンの側に "Hello World" というテキストが表示されるのが確認できます。確認した後は再生モードを抜けます。

Attach:Scripting-5.png


!! ゲームオブジェクトの微調整

``print()`` ステートメントはスクリプトをデバッグするうえでは非常に便利ですが、アタッチされているゲームオブジェクトを変更しません。スクリプトを変更して機能を少し追加します:


[@function Update () {
    transform.Rotate(0, 5*Time.deltaTime, 0);
} @]


もしスクリプティングが初めての場合、これが難しく見えても問題ありません。次が覚えるべき重要な概念です:

# ``function Update () {}`` はUnityが1秒間に複数回（フレームごとに1回）実行するコードのコンテナです。
# ``transform`` はゲームオブジェクトの[[class-Transform | Transform コンポーネント]] への参照です。
# ``Rotate()`` は Transform $$Component$$ に含まれる関数です。
# カンマの間の数は3D空間 におけるX, Y, Z軸の周りの回転を示します。
# ``Time.deltaTime`` は Time クラスのメンバであり、1秒間の間の動作をスムーズにして、マシンが1秒間あたり何フレームでレンダリングしているかに関わらず同じスピードでキューブが回転するようにしています。``5 * Time.deltaTime`` は1秒あたり5度を示します。

これらを全て頭に入れたうえで、このコードを読み取ると、 "毎フレームごとに、ゲームオブジェクトのTransformコンポーネントを少しづつY軸の回りに1秒間に5度スムーズに回転させる"

すでに ``transform`` をアクセスした方法と同様にして、さまざまなコンポーネントを同じようにアクセスすることが出来ます。ゲームオブジェクトにコンポーネントを追加するのに ^^Component^^ メニューを使用します。直接にアクセスできる全てのコンポネーントは [[Path:../ScriptReference/GameObject.html|ゲームオブジェクト スクリプティング リファレンス ページ]] の $$Variables$$ として一覧で表示されています。

ゲームオブジェクト、スクリプト、およびコンポーネントの関係については、このマニュアルの [[GameObjects]] ページまたは [[Using Components]] ページへと先に読み進めてください。


!! 変数の威力

ここまでのスクリプトはつねに毎秒5度回転します。毎秒異なる角度だけ回転させたいかもしれません。数字を変更して保存することも出来ますが、その場合はスクリプトがリコンパイルされて、結果をみるために 実行モードに入る必要があります。もっと早い方法があります。実行モードの際にリアルタイムで回転の速度を試すことができて、非常に簡単な方法なのです。

``Rotate()`` 関数で ``5`` と入力する代わりに、 ``speed`` 変数を宣言して、それを関数で使用します。スクリプトを次のコードおのとおりに変更して保存して下さい:

[@var speed = 5.0;

function Update () {
    transform.Rotate(0, speed*Time.deltaTime, 0);
}@]

次に、キューブを選択して、インスペクタをみて下さい。 ``speed`` 変数が表示されていることに気がつきます。

Attach:Scripting-6.png

この変数はインスペクタで直接編集することが出来ます。それを選択して、^^Enter^^ を押して値を変更します。さらに値の上で右クリックまたOptionクリックしてマウスを上下にドラッグできます。ゲームが実行中の場合を含めて、値はいつでも変更できます。

Play をクリックして ``speed`` 値を変更してください。キューブの回転スピードは瞬時に変更されます。実行モードを出たとき、行った変更が全て実行モードに入る前の値に戻っていることが確認できます。これにより、再生、調整、試行を行ってもっともベストの値をみつけて、その後にこの値を永続的に反映させることが出来ます。

変数の値をインスペクタで変更できるテクニックにより、ひとつのスクリプトを複数のオブジェクトで、各々異なった変数の値で、再利用するのに役立ちます。もしスクリプトを複数のキューブにアタッチして、各々のキューブの ``speed``  を変更すると、それらは同じスクリプトであるにも関わらず全て異なるスピードで回転します。


!! 他のコンポーネントへのアクセス

スクリプトコンポーネントを記述するとき、そのスクリプトの中から同じゲームオブジェクト上の他のコンポーネントをアクセスできます。

!!! ゲームオブジェクトメンバーの使用

``GameObject`` クラスのメンバーを直接アクセスすることが出来ます。``GameObject`` クラスメンバーの全ての一覧は [[class-GameObject| ここ]] でみることが出来ます。もし示されたクラスのどれかがゲームオブジェクトにクラスとしてアタッチされていれば、そのコンポーネントを直接スクリプトを通して、メンバー名を記述するだけで、アクセスすることが出来ます。 例えば、``transform`` と記述するのは ``gameObject.transform`` と記述するのと同等です。``gameObject`` は、明示的に別のゲームオブジェクトを参照するように指定しないかぎり、コンパイラが認識するため省力ができます。

``this`` と入力すると、記述しているスクリプトのコンポーネントをアクセスすることになります。``this.gameObject`` と記述すると、アタッチされているゲームオブジェクトを指します。同じゲームオブジェクトへアクセスするには単に ``gameObject`` と記述します。論理的には、``this.transform`` と入力することは``transform`` と記述することで同じです。もしゲームオブジェクトとして含まれてないコンポーネントをアクセスしたい場合は、次のページで説明するように``gameObject.GetComponent()`` を使用する必要があります。

どんなスクリプトからも直接アクセスすることの出来るコンポーネントがたくさんあります。例えば、もしTransform コンポーネントの ``Translate`` をアクセスしたい場合、``transform.Translate()`` または ``gameObject.transform.Translate()`` と記述すればよいだけです。これが正しく動作するのは、全てのスクリプトがゲームオブジェクトにアタッチされているためです。このため、``transform`` と記述したときは、明示的にスクリプトが書かれているゲームオブジェクトの Transfom コンポーネントをアクセスしています。明示的にするためには、 ``gameObject.transform`` と記述します。各々の記述方法には優劣はなく、スクリプトを書く人の好みとなります。

明示的にアクセスすることが出来る全てのコンポーネントの一覧については [[ScriptRef:GameObject.html | GameObject]] page in the [[ScriptRef:index.html |スクリプティング リファレンス]] を参照してください。

!!! ``GetComponent()`` の使用

``GameObject``クラスのメンバーとしてダイレクトに参照されないコンポーネントがたくさんあります。このため、これらは暗黙的にアクセスすることが出来ず、明示的ににアクセスする必要があります。このためには、 ``GetComponent("コンポーネント名")`` をコールして結果への参照を格納します。もっとも良くあるのはゲームオブジェクトにアタッチされた別のスクリプトへの参照を作成した場合です。

''Script B'' を記述していると仮定して、同じゲームオブジェクトにアタッチされている''Script A''への参照を作成したいとします。 ``GetComponent()`` を使用してこの参照を行います。Script Bでは次のように記述するのみです:

``scriptA = GetComponent("ScriptA");``

``GetComponent()`` を使用するうえでの詳細については [[ScriptRef:GameObject.GetComponent.html | GetComponent() Script Reference page]].
For more help with using ``GetComponent()``, take a look at the [[ScriptRef:GameObject.GetComponent.html | スクリプティング リファレンスの GetComponent() ページ]] を参照して下さい。


!! 他のスクリプト コンポーネント変数へのアクセス

ゲームオブジェクトにアタッチされた全てのスクリプトはコンポーネントでえす。このため、スクリプトからのパブリック変数（およびメソッド）へのにはGetComponentメソッドを使用します。例えば:

[@function Start () {
   // このスクリプトがアタッチされているゲームオブジェクトの Transform コンポーネントの位置を出力
   Debug.Log(gameObject.GetComponent<Transform>.().position);
}@]

前述の例では GetComponent<T>. 関数 を使用してTransform コンポーネントの position プロパティをアクセスしました。同じテクニックをカスタムスクリプトのコンポーネントの変数にアクセスするために使用できます。


[@(MyClass.js)
public var speed : float = 3.14159;

(MyOtherClass.js)
function Start () {
   // ゲームオブジェクトにアタッチされた MyClass スクリプト コンポーネント から speed 変数を出力
   Debug.Log(gameObject.GetComponent<MyClass>.().speed);
}@]


!!! Javascriptから C# で定義された変数をアクセス

C# スクリプトで定義された変数をアクセスするためには、C# コードを含む コンパイルされたアセンブリ が Javascript コードがコンパイルされたときに存在している必要があります。Unity は異なるステージでのコンパイルについて、スクリプティング リファレンスの [[Path:../ScriptReference/index.Script_compilation_28Advanced29.html|スクリプト コンパイル]] セクションで説明しているように行います。もしC# スクリプトでのクラスや変数 を使用する Javascript を作成したい場合、 "Standard Assets", "Pro Standard Assets",  または "Plugins" フォルダに C# スクリプトを配置して、Javascript スクリプトをこれらのフォルダとは別のところに配置します。"Standard Assets", "Pro Standard Assets", または "Plugins" に含まれるコードは先にコンパイルされ、その外のコードはその後のステップでコンパイルされます。すなわちコンパイル段階で定義された型 (C# スクリプトの中のもの) はその後のステップ（Javascriptスクリプト）で利用可能です。

一般的には "Standard Assets", "Pro Standard Assets",  または "Plugins" フォルダに含まれるコードは言語（C#, Javascript, または Boo）に関わらず最初にコンパイルされ、そして後続のコンパイル段階で利用可能となります。

!!! 変数アクセスの最適化

いくつかの状況ではGetComponentをコードの中で複数回、またはフレームごとに複数回使用しているかもしれません。GetComponentへのコールは必要なコンポーネントへの参照を取得するために内部的にステップが余分に必要となります。より効果的なアプローチは例えば Start() 関数などの中で参照を格納することです。参照を格納するだけであり、直接取得しているわけではないので、null 参照を事前にチェックするのは良い習慣です。

[@(MyClass.js)
public var speed : float = 3.14159;

(MyOtherClass.js)
private var myClass : MyClass;
function Start () {
   // ゲームオブジェクト にアタッチされた MyClass スクリプト コンポーネントへの参照を取得
   myClass = gameObject.GetComponent<MyClass>.();
}
function Update () {
   // 参照がまだ有効であることをチェックして、speed 変数を出力
   if(myClass != null)
      Debug.Log (myClass.speed);
}
@]

!!! Static 変数

さらにクラスの中で変数を static と宣言することも出来ます。この場合は特定のクラスの static 変数は一つのみ存在し、そしてクラスオブジェクトのインスタンスがなくとも変更することが出来ます。

[@(MyClass.js)
static public var speed : float = 3.14159;

(MyOtherClass.js)
function Start () {
   Debug.Log (MyClass.speed);
}@]

使用されないオブジェクトをメモリから取り除くため、オブジェクト参照のためにstatic 変数を使用 __しない__ ことを推奨します。

!! この先どうするか

これはエディタの中でスクリプトを使用するための、短い紹介文でした。より多くのサンプルについては、アセットストアで無料で利用可能な Unity チュートリアルを確認します。Unityのスクリプトに関するより詳細なチュートリアルや、より深い情報に関するポイントは、スクリプトリファレンスの [[Path:../ScriptReference/index.html|スクリプト概要]] を参照下さい。もし詰まってしまった場合は [[http://answers.unity3d.com | Unity Answers]] または [[http://forum.unity3d.com | Unity Forums]] を訪れて、そこで質問をしてください。常に誰かが助けようとしてくれています。
