! ドローコール バッチング　(Draw Call Batching)
スクリーンにオブジェクトを描画するために、描画エンジンはOpenGLやDirect3DのグラフィックAPIにドローコール(draw call)を発行しなければいけません。どんな一回のドローコールでも多くのグラフィックAPIの集まりが必要になります。つまりこれはCPUパフォーマンスのオーバーヘッドに重大な影響をもたらします。

Unityはランタイムで複数のオブジェクトを合成し、一回のドローコールで同時に描画します。この処理は「バッチング(batching)」と呼ばれます。Unityがより多くのオブジェクトを一緒にバッチングできれば、レンダリングのパフォーマンスはより良くなるということになります。

Unity内に組み込まれているバッチングは、単なるモデリングツールでのジオメトリ合成（またはStandard Assets packageの``CombineChildren`` スクリプトの利用）以上に、絶大な効果があります。Unity内のバッチングは見える範囲に入った__後__ に処理が走ります。描画エンジンはどのオブジェクトも個別にカリング（間引き）しますので、レンダリングされたジオメトリの集合はバッチングしないのと同じになります。一方で、モデリングツールのジオメトリ合成は効果的なカリングを阻害し、結果的に多くのジオメトリをレンダリングすることになります。


!! マテリアルについて
同じマテリアルを共有しているオブジェクトがバッチング可能になります。そのため、より効果的なバッチングをするには、できる限り違うオブジェクト間で多くのマテリアルを共有する必要があります。

もし二つのテクスチャが違うだけの独立したマテリアルがあるのであれば、二つのテクスチャを組み合わせて一つのテクスチャに合成しましょう（ [[http://en.wikipedia.org/wiki/Texture_atlas | ''テクスチャアトラス(texture atlasing)'']] と呼ばれるプロセスです）。いったんテクスチャを同じアトラスにしてしまえば、単一のマテリアルとして使うことができるようになります。

もしスクリプトから共有しているマテリアルプロパティをアクセスするならば、以下の情報が重要です：[[ScriptRef:Renderer-material.html | Renderer.material]] の変更はマテリアルのコピーが生じます。共有しているマテリアルをキープしたいのであれば、代わりに [[ScriptRef:Renderer-sharedMaterial.html | Renderer.sharedMaterial]] を使いましょう。


!! ダイナミック（動的）バッチング
同じマテリアルを共有しているのであれば、Unityは自動的に動いているオブジェクトをバッチングします。

ダイナミックバッチングは自動的に処理されるので、何かの手間が必要というわけではありません。

Tips:

* 動的なオブジェクトのバッチングは__頂点ごとに__ ある程度オーバーヘッドがあります。ですので、バッチングはトータル頂点数が900以下のメッシュでしか適応されません。
** シェーダーが頂点位置や法線や一つのUV情報を使っていたら、300頂点までになります。さらに頂点位置、法線、UV0、UV1、タンジェントを使っていたら180頂点までになります。
** __ご注意: ただこの制限値は今後変更されるかもしれません__
* スケールは使わないで下さい。 スケールが(1,1,1) のオブジェクトと (2,2,2) のオブジェクトはバッチングされません
* 線形スケールされたオブジェクトは非線形スケールされたオブジェクトとバッチングされません。
** スケールが(1,1,1) のオブジェクトと (1,2,1) のオブジェクトはバッチングされません。ただ一方で、スケールが(1,2,1) のオブジェクトと (1,3,1) のオブジェクトはバッチングされます（二つとも非線形なので）。
* 違うマテリアルのインスタンスを持つ場合はバッチングに失敗します。
* ライトマップを持つオブジェクトは追加の隠しマテリアルパラメータ（ライトマップでのオフセット／スケール）を持っています。ですのでライトマップを持つオブジェクトはバッチングされません（ライトマップでの同じ位置でなければ、ですが）。
* マルチパスのシェーダはバッチングを阻害します。例：Unityの用意するシェーダは全てフォワードレンダリングで複数ライトをサポートしていますが、それらは追加のパスを使っています。
* プレハブのインスタンスを生成すると、自動的に同じメッシュとマテリアルを使うようになります。

!! スタティック（静的）バッチング
一方でスタティックバッチングはどんなサイズのジオメトリでもドローコールを減らすことが出来ます（動かなくて同じマテリアルを共有することが条件です）。スタティックバッチングはダイナミックバッチングよりも顕著に効果が出ます。CPUパワーを減らす必要があるなら是非スタティックバッチングを選択して下さい。

スタティックバッチングの利用するには、そのオブジェクトがゲーム中、動いたり、回転したり、スケールしたりするということが__ない__ ということを明示的に設定する必要があります。InspectorのStaticチェックボックスをオンにすると、その設定になります。:
Attach:StaticTagInspector.png

スタティックバッチングを使うと、合成したジオメトリ情報を保存しておくためのメモリが余計に必要になります。もしスタティックバッチングの前に、複数のオブジェクトで同じジオメトリを共有しているのであれば、オブジェクトごとにジオメトリのコピーがおこります（エディタ上でもランタイムでも）。このことから、いつでもお勧めする方法ではありません。つまり場合によっては、小さいメモリ使用量を維持するために、スタティックバッチングを避けて、レンダリングのパフォーマンスを犠牲になければならないこともあるでしょう。例えば、密集した森林において、木をスタティックにすると、メモリにはかなりの負担になるかもしれません。

スタティックバッチングはUnity Pro専用で、どのプラットフォームでも利用可能です。


!! Other batching tips

Currently, only [[class-MeshRenderer | Mesh Renderers]] and [[Particle Systems]] are batched. This means that skinned meshes, cloth, trail renderers and other types of rendering components are __not__ batched.

Semitransparent shaders most often require objects to be rendered in back-to-front order for transparency to work. Unity first orders objects in this order, and then tries to batch them - but because the order must be strictly satisfied, this often means less batching can be achieved than with opaque objects.

Some parts of Unity's rendering do not have batching implemented yet; for example rendering shadow casters, camera's depth textures or GUI will not do batching.




