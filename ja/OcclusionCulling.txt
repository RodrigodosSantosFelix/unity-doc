! オクルージョンカリング (Proのみ)
オクルージョンカリングは、他のオブジェクトに覆い隠されてカメラに映らなくなってしまったオブジェクトのレンダリングを無効化する機能です。3Dコンピュータグラフィックスの世界においては大抵の場合、カメラから遠いオブジェクトから先に描画され、より近くにあるオブジェクトが次々と上書き（「オーバードロー」と呼びます）されます。オクルージョンカリングはそれほど当たり前の機能ではないのです。オクルージョンカリングは視錐台カリングとは異なります。視錐台カリングはカメラの表示領域から外れたオブジェクトの描画を無効化するだけであり、オクルージョンカリングのようにオーバードローにより見えなくなるオブジェクトの描画は無効化しません。なお、オクルージョンカリングを使いながら、同時に視錐台カリングの恩恵を受けることが可能です。

Attach:OcclusionCullingOff.png\\
''オクルージョンカリングなしで描画されたシーン''

Attach:OcclusionCullingOn.png\\
''オクルージョンカリングありで描画された同一のシーン''

オクルージョンカリングの処理では、まず仮想的なカメラを使ってシーン全体が走査され、可視状態になり得るオブジェクトの階層構造が生成されます。ゲームの実行時には各カメラがこのデータを利用して、何が可視で何が不可視化かを識別します。その識別結果を利用して、Unityは可視状態のオブジェクトだけを描画に回します。その結果、ドローコール数が減少し、ゲームのパフォーマンスが向上します。

オクルージョンカリングに用いられるデータは複数のセル（Cell）で構成されています。各セルはシーン全体のバウンディングボリューム（Bounding Volume）を分割したものです。そしてより詳細には、これらのセルは２分木を構成しています。オクルージョンカリングは二つの木構造データを使います。一つはView Cells（静的オブジェクト向け）で、もう一つはTarget Cells（移動するオブジェクト向け）です。View Cellsは可視の静的オブジェクトのインデックスに紐付けられていて、静的オブジェクト向けにより正確なカリング結果を提供するために使われます。

ゲームオブジェクトを作成するときには、このセルのことを心に留めておくと良いでしょう。なぜなら、ゲームオブジェクトのサイズと、セルのサイズのバランスをうまい具合に取る必要があるからです。理想的には、オブジェクトに対して小さすぎるセルや、逆に複数のセルにまたがるようなオブジェクトも作るべきではありません。大きなオブジェクトを小さなピースに分割することで、カリングの効果が向上することがあります。しかしながら、その一方ではドローコールを削減するためには小さなオブジェクトをマージすることもできます。そして、同じセルに含まれているオブジェクト同士にはオクルージョンカリングの効果は発動しない、という点も注意が必要です。どのセルがどのセルから見て表示状態になるか、という判定に使われるセルと表示情報のことを、あわせて PVS (__P__otentially __V__isible __S__et) と呼びます。


!! オクルージョンカリングの設定

オクルージョンカリングを利用するにあたっては、いくつかの手作業が必要になります。まず、レベルのジオメトリを程良い大きさのピースに分割しておかなければなりません。さらにレベルを明確に定義された、出来るだけ小さなエリア毎にまとまるように配置することもおすすめします。エリアの粒度は、例えばレベルに存在する壁やビルなどの非常に大きなオブジェクトに一度に閉塞されるようなもの同士がまとまる程度にすると良いでしょう。この考え方は、個々のメッシュがオクルージョンのデータに基いて有効化または無効化されるというものです。したがって、例えばあなたのレベルにたった一つのオブジェクトしか無く、しかもその中に部屋と全ての家具のメッシュが含まれているような場合には、全てがカリングされるか、または何もカリングされないか、の２択になってしまいます。これでは意味がありません。また、家具のパーツ毎にメッシュをわけて、それぞれのパーツがカメラの視点に基いてカリングされるようにする、ということも同じくらい意味がありません。

シーン内でオクルージョンを適用する全てのオブジェクトには $$Inspector$$ 内で ^^Occluder Static^^ タグをつける必要があります。これを行う最速の方法は、オクルージョンの計算に含めたいオブジェクトを複数選択し、 ^^Occluder Static^^ および ^^Occludee Static^^ のチェックマークをつけることです。

Attach:OcclusionStaticDropdown.png
'オブジェクトのオクルージョンのためチェックマークをつける'

^^Occludee Static^^ をどのような場合に利用できるか説明します。他のオブジェクトを遮ることがない透明なオブジェクトや小さなオブジェクトには、 ^^Occluders^^ ではなく ^^Occludees^^ のチェックマークをつけるべきです。このチェックが付けられたオブジェクトは、他のオブジェクトによる遮蔽判定の時には考慮され、遮蔽する側として判定時には無視されます。これにより計算コストが下がります。

!!Occlusion Culling Window
オクルージョンカリングに関して何か操作するときは、Occulusion Culling ウインドウ (^^Window->Occlusion Culling^^) を利用すると良いでしょう。

Occulusion Culling ウインドウでは、遮蔽する側になるメッシュの設定や、[[class-OcclusionArea|Occlusion Areas]] の設定が行えます。

^^Occlusion Culling ウインドウ^^ の ^^Object^^ タブを表示中で、かつシーン内の [[class-MeshRenderer|Mesh Renderer]] を選択している場合は、それに Static 関連のフラグを変更することができます。
Attach:OcclusionCullingInspectorObject.png\\
''メッシュレンダラー用の Occlusion Culling ウインドウ'

^^Occlusion Culling ウインドウ^^ の ^^Object^^ タブを表示中で、かつ [[class-OcclusionArea|Occlusion Area]] を選択している場合は、オクルージョンエリア関連のプロパティを変更することができます（詳細については、 [[class-OcclusionArea|Occlusion Area]] を参照してください）。
Attach:OcclusionCullingInspectorOcclusionArea.png\\
''オクルージョンエリア用のOcclusion Culling ウインドウ''

__NOTE:__ オクルージョンエリアを一つも作成していない場合、デフォルトではシーン全体にオクルージョンカリングが適用されます。

__NOTE:__ カメラがオクルージョンエリア外にある場合、オクルージョンカリングは適用されません。したがって、カメラが移動する可能性のある場所を全てカバーするようにオクルージョンエリアを設定しておくことは重要です。しかし、オクルージョンエリアをあまりに大きしすぎると、今度はベイク処理に時間がかかるようになってしまいます。



!! オクルージョンカリング - Bake

Attach:OcclusionCullingInspectorBake.png\\
''オクルージョンカリングインスペクタの Bake タブ'

!! Properties
||PROPS
||``Technique`` ||オクルージョンカリングのベイク処理のタイプを選択します ||
||>>>``PVS only`` ||静的オブジェクトだけがオクルージョンカリングの対象になります。動的オブジェクトには視錐台カリングのみ適用されます。この方式はCPU負荷が最も小さくなります。しかし、動的オブジェクトがカリングされないという特性上、移動するオブジェクトやキャラクターが数えるほどしか存在しない場合にだけ利用することをお奨めします。また、この方式ではオブジェクトの可視性は事前に計算される都合上、ゲーム実行時にオクルージョンポータルを開閉することはできなくなります。 ||
||>>>``PVS and dynamic objects`` ||静的オブジェクトは事前に計算された可視性に基いてカリングされます。動的オブジェクトやポータルを基準としてカリングされます。この方式は、カリングの効率的とゲーム実行時のオーバーヘッドのバランスがとれています。この方式では可視性が事前に計算される都合上、ゲーム実行時にオクルージョンポータルを開閉することはできません。 ||
||>>>``Automatic Portal Generation`` ||オクルージョンポータルが自動生成されます。静的オブジェクト、動的オブジェクト共にポータルを経由してカリングされます。この方式では、ゲーム実行時にポータルを開閉することができます。カリングの精度は最も高い方式ですが、同時にCPUへの負荷も一番高くなります。 ||
||``View Cell Size`` ||View Cellのサイズです。値が小さいほどオクルージョンカリングの精度が高くなりますが、同時にストレージサイズも増えてしまうというトレードオフがあります。 ||
||``Near Clip Plane`` ||ゲーム内の全てのカメラによって利用される最小のニアクリッププレーンを指定すべきです ||
||``Far Clip Plane`` ||ファークリッププレーンはオブジェクトのカリングに利用されます。ここで設定された距離より遠くにあるオブジェクトは自動的にカリングされます。（ゲーム内の全てのカメラによって利用される最大のファープレーンクリップを指定すべきです） ||
||``Memory limit`` ||PVSベースのベイク処理のヒントとなる数値です。"Automatic Portal Generation" モードでは無効になります。
これらの値の調整が完了したら、 ^^Bake^^ ボタンをクリックしてオクルージョンカリングのための事前計算を開始しましょう。もし、結果に満足できなかった場合は、 ^^Clear^^ ボタンをクリックすると前回の計算結果を消去することができます。

!! オクルージョンカリング - Visualization

Attach:OcclusionCullingInspectorVisualization.png\\
''オクルージョンカリングインスペクタの Visualization タブ''

ニアクリッププレーンとファークリッププレーンは内部的に、オクルージョンカリングの計算で利用される仮想的なカメラを生成します。ゲーム内に異なるニアクリッププレーンまたはファークリッププレーン値が設定されたカメラが複数存在する場合に正しいかリング結果を得るためには、全てのカメラに最小のニアクリッププレーンと最大のファークリッププレーンを設定すべきです。 


バウンディングボリュームのサイズはシーン内の全てのオブジェクトに影響されるため、できるだけ全てのオブジェクトがシーンの可視領域に収まるようにしてください。


オクルージョンデータを生成する準備ができたら、 ^^Bake^^ ボタンをクリックしましょう。その際、 ^^Bake^^ タブにある ^^Memory Limit^^ の値を正しく選択しましょう。この値が小さいほどデータの生成は高速になり、内容は不正確になります。逆に値が大きいほどリリースに向けた製品レベルのクオリティに近づいていきます。

オクルージョンデータの生成にかかる時間はセルの詳細さとデータサイズ、選択したクオリティに左右されることに注意してください。Unityはメインウインドウの下部にPVS生成の状況を表示します。

生成処理が完了したら、ビューエリアにカラフルな立方体が表示されます。この立方体に同じ色に着色されている領域は、それぞれ同じオクルージョンデータを共有しています。

^^Clear^^ ボタンをクリックすると、オクルージョンカリングのために事前計算されたデータを消去できます。

(:include class-OcclusionArea:)
(:include class-OcclusionPortal:)
